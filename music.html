<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Music</title>
<link rel="stylesheet" href="music_style.css">
<link rel="stylesheet" href="mediaqueries.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

</head>

<body>
  <div class="page-veil" id="pageVeil" aria-hidden="true"></div>

<!-- GLOBAL BACKGROUND (sits behind the whole site) -->
    <div id="bg-global" aria-hidden="true"></div>

<!-- DESKTOP NAV -->
<nav id="desktop-nav">
  <div>
    <ul class="nav-links">
      <li><a href="travel.html" 
        target="_blank" 
        rel="noopener noreferrer">Travel</a></li>
      <li><a href="movie.html" target="_blank" 
        rel="noopener noreferrer">Movie & Book</a></li>
      <li><a href="doodle.html" target="_blank" 
        rel="noopener noreferrer">Doodle</a></li>
      <li><a href="index.html" target="_blank" 
        rel="noopener noreferrer">Home</a></li>

    </ul>
  </div>
</nav>

<!-- HAMBURGER NAV -->
<nav id="hamburger-nav">
  <div class="hamburger-menu">
    <div class="hamburger-icon" onclick="toggleMenu()">
      <span></span>
      <span></span>
      <span></span>
    </div>
    <div class="menu-links">
      <li><a href="travel.html"  target="_blank" 
        rel="noopener noreferrer" onclick="toggleMenu()">Travel</a></li>
      <li><a href="movie.html"  target="_blank" 
        rel="noopener noreferrer"onclick="toggleMenu()">Movie&nbsp;&amp;&nbsp;Book</a></li>
      <li><a href="doodle.html"  target="_blank" 
        rel="noopener noreferrer" onclick="toggleMenu()">Doodle</a></li>
      <li><a href="index.html"  target="_blank" 
        rel="noopener noreferrer" onclick="toggleMenu()">Home</a></li>
    </div>
  </div>
</nav>


<section id="music">
  <!-- Left & Right Arrows (screen edges) -->
<!-- Left -->
<!-- Left -->
<div class="music-container">
  <button class="nav-arrow nav-left" id="btnPrev" 
          aria-label="Previous"
          data-hint="Also can use ← and → keys to swipe">
    <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
        fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
        width="50" height="50" >
      <path d="m9 13 3 -3 3 3" stroke-width="2"></path>
      <path d="M3 12a9 9 0 1 0 18 0 9 9 0 1 0 -18 0" stroke-width="2"></path>
    </svg>
  </button>

<!-- Right -->
<button class="nav-arrow nav-right" id="btnNext" 
        aria-label="Next"
        data-hint="Also can use ← and → keys to swipe">
  <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
       fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
       width="50" height="50">
    <path d="m9 13 3 -3 3 3" stroke-width="2"></path>
    <path d="M3 12a9 9 0 1 0 18 0 9 9 0 1 0 -18 0" stroke-width="2"></path>
  </svg>
</button>



  <!-- Stack -->
  <div class="image-stack-root" aria-label="3D Image Stack">
    
    <div class="image-stack-persp" id="stackPersp">
      <div class="stack-rotator" role="group" aria-roledescription="stack of images">
        <!-- Back to front (1 → 5) -->
        <a class="stack-card card-1" href="#" aria-label="Card 1">
          <img id="img1" class = "card-img" src="https://picsum.photos/seed/stack1/800/600" alt="Stack Image 1" fetchpriority="low" />
        </a>

        <a class="stack-card card-2" href="#" aria-label="Card 2">
          <img id="img2" class = "card-img" src="https://picsum.photos/seed/stack2/800/600" alt="Stack Image 2" fetchpriority="low" />
        </a>

        <a class="stack-card card-3" href="#" aria-label="Card 3">
          <img id="img3" class = "card-img" src="https://picsum.photos/seed/stack3/800/600" alt="Stack Image 3" fetchpriority="high" />
        </a>

        <a class="stack-card card-4" href="#" aria-label="Card 4">
          <img id="img4" class = "card-img" src="https://picsum.photos/seed/stack4/800/600" alt="Stack Image 4" fetchpriority="high" />
        </a>

        <a class="stack-card card-5" href="#" aria-label="Card 5">
          <img id="img5" class = "card-img" src="https://picsum.photos/seed/stack5/800/600" alt="Stack Image 5" fetchpriority="high" />
        </a>
      </div>
    </div>
  </div>

  <!-- Pop-out viewer elements -->
  <div class="popout-backdrop" id="popBackdrop" aria-hidden="true"></div>
  <button class="popout-close" id="popClose" aria-label="Close (Esc)">
    <svg viewBox="0 0 24 24"><path d="M6 6l12 12M18 6L6 18"/></svg>
  </button>

</div>
</section>


<!-- Popout controls template -->
<template id="popoutControlsTpl">
  
  <div class="popout-note" id="track-note" aria-live="polite"></div>

  <div class="popout-controls">
  
    <h2 id="music-title"></h2>
    <h3 id="music-artist"></h3>
    <div class="player-progress" id="player-progress">
      <div class="progress" id="progress"></div>
      <div class="music-duration">
          <span id="current-time">0:00</span>
          <span id="duration">0:00</span>
      </div>
    </div>

    <div class="player-controls">
      <i class="fa-solid fa-backward" title="Previous" id="prev"></i>
      <i class="fa-solid fa-play play-button" title="Play" id="play"></i>
      <i class="fa-solid fa-forward" title="Next" id="next"></i>
    </div>
  </div>
</template>


<section class="hero">
  <div class="tw-wrap">
    <span class="tw line1">或许有一天这个网站会年久失修</span>
    <span class="tw line2">但我应该还会在听歌</span>
  </div>
  </section>



<!-- JS PART -->
<script src="script.js"></script>

<!-- background -->
 
     <!-- Dependencies (CDNs are easiest for a static site) -->
     <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
 
     <!-- The browser build of hover-effect.
         If you have it locally, change the path to where you saved it, e.g. /vendor/hover.umd.js -->
     <script src="https://cdn.jsdelivr.net/npm/hover-effect@latest/dist/hover-effect.umd.js"></script>
 
     <script>
       // Paths to your two background images + displacement texture.
       // Put your files into /assets/ and update names as needed.
       const BG1  = "./music/music_bg1.jpg";       // first photo
       const BG2  = "./music/music_bg2.jpg";       // second photo
       const DISP = "./music/music_displace.png"; // the distortion map you downloaded
 
       const container = document.getElementById("bg-global");
 
       // Helper so the image covers the viewport nicely
       function viewportRatio() {
         return window.innerHeight / window.innerWidth;
       }
 
       // Create the global effect once
       const bgEffect = new hoverEffect({
         parent: container,
         image1: BG1,
         image2: BG2,
         displacementImage: DISP,
         intensity: 0.65,               // distortion amount (0–1 typically)
         speedIn: 15,
         speedOut: 15,
         easing: "Expo.easeOut",
         hover: true,                   // morph on hover/leave anywhere on the page
         imagesRatio: viewportRatio()
       });
 
       // Keep coverage correct on resize
       addEventListener("resize", () => {
         bgEffect.options.imagesRatio = viewportRatio();
       });
 
       // OPTIONAL: make it gently auto-cycle every few seconds (even without hover)
       // Uncomment if you want ambient morphing
       
       let showingSecond = false;
       setInterval(() => {
         showingSecond ? bgEffect.previous() : bgEffect.next();
         showingSecond = !showingSecond;
       }, 8000); // every 8s
       
     </script>


<script>
(async () => {
  // ---------- Data & state ----------
  const BATCH = 5;
  let batchIndex = 0;
  let isAnimating = false;

  let activeLayer = null;
  let activeControls = null;
  let teardownControls = null;
  let activeIndex = null; // <— use index instead of src

  const TRACKS = await fetch('assets/tracks.json').then(r => r.json());
  const batches = Math.ceil(TRACKS.length / BATCH);

  // ---------- DOM ----------
  const persp   = document.getElementById('stackPersp');
  const imgEls  = [
    document.getElementById('img1'),
    document.getElementById('img2'),
    document.getElementById('img3'),
    document.getElementById('img4'),
    document.getElementById('img5'),
  ];
  const btnPrev = document.getElementById('btnPrev');
  const btnNext = document.getElementById('btnNext');

  const backdrop = document.getElementById('popBackdrop');
  const btnClose = document.getElementById('popClose');


 /* show hint once per page load (no storage) */
/* show the tip once per arrow per page load */
(function setupArrowHintsPerLoad(){
  function wireOnce(el){
    if (!el) return;
    el.addEventListener('mouseenter', () => {
      el.classList.add('show-hint');           // show tip
      el.addEventListener('mouseleave', () => {
        el.classList.remove('show-hint');      // hide after first leave
      }, { once: true });
    }, { once: true });                         // only first hover triggers
  }
  wireOnce(btnPrev);
  wireOnce(btnNext);
})();

  // If hamburger JS isn’t present elsewhere
  window.toggleMenu = window.toggleMenu || function toggleMenu(){
    const icon = document.querySelector('.hamburger-icon');
    const links = document.querySelector('.menu-links');
    icon?.classList.toggle('open');
    links?.classList.toggle('open');
  };

  // ---------- Helpers ----------
  const preload = (urls) => urls.forEach(u => { const i = new Image(); i.src = u; });
  const preloadBatch = (index) => {
    const urls = getBatchIndices(index).map(i => TRACKS[i].image);
    preload(urls);
  };

  function getBatchIndices(index){
    const out = [];
    for (let i = 0; i < BATCH; i++) out.push((index * BATCH + i) % TRACKS.length);
    return out;
  }

  function setImages(indices){
    indices.forEach((trackIdx, i) => {
      const t = TRACKS[trackIdx];
      imgEls[i].src = t.image;
      imgEls[i].alt = t.title || `Track ${trackIdx+1}`;
      imgEls[i].dataset.trackIndex = String(trackIdx);
    });
    refreshEdgeFaces();
  }

  function refreshEdgeFaces() {
    const cards = Array.from(document.querySelectorAll('.stack-card')); // 1..5
    for (let i = 0; i < cards.length; i++) {
      const img = imgEls[i];
      if (!img) continue;
      const url = (img.currentSrc || img.src || '').replace(/"/g, '\\"');
      cards[i].style.setProperty('--edge-img', `url("${url}")`);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', refreshEdgeFaces, { once: true });
  } else {
    refreshEdgeFaces();
  }

  // ---------- Paging animation ----------
  function animateSwap(direction){
    if (!persp) return;
    if (persp.classList.contains('anim-out-left') ||
        persp.classList.contains('anim-out-right') ||
        persp.classList.contains('anim-in-left') ||
        persp.classList.contains('anim-in-right')) return;

    const outClass = direction === 'next' ? 'anim-out-left' : 'anim-out-right';
    const inClass  = direction === 'next' ? 'anim-in-right' : 'anim-in-left';

    persp.classList.add(outClass);

    const handleOutEnd = (e) => {
      if (e.target !== persp) return;
      persp.removeEventListener('animationend', handleOutEnd);
      persp.classList.remove(outClass);

      batchIndex = (direction === 'next')
        ? (batchIndex + 1) % batches
        : (batchIndex - 1 + batches) % batches;

      setImages(getBatchIndices(batchIndex));
      preloadBatch((batchIndex + 1) % batches);

      persp.classList.add(inClass);
      const handleInEnd = (e2) => {
        if (e2.target !== persp) return;
        persp.removeEventListener('animationend', handleInEnd);
        persp.classList.remove(inClass);
      };
      persp.addEventListener('animationend', handleInEnd, { once: true });
    };

    persp.addEventListener('animationend', handleOutEnd, { once: true });
  }

  // ---------- Init first batch ----------
  setImages(getBatchIndices(0));
  preloadBatch(1);

  // ---------- Arrows/keys ----------
  btnNext?.addEventListener('click', () => animateSwap('prev')); // reversed by design
  btnPrev?.addEventListener('click', () => animateSwap('next'));
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowRight') animateSwap('prev');
    if (e.key === 'ArrowLeft')  animateSwap('next');
  });

  // ---------- Popout ----------
  function attachControls(layer, startIndex){
    const tpl = document.getElementById('popoutControlsTpl');
    const frag = tpl.content.cloneNode(true);
    const controls = frag.querySelector('.popout-controls');

    const noteEl = frag.querySelector('#track-note'); 

    layer.appendChild(frag);

    const titleEl = controls.querySelector('#music-title');
    const artistEl = controls.querySelector('#music-artist');
    const currentEl = controls.querySelector('#current-time');
    const durEl = controls.querySelector('#duration');
    const progress = controls.querySelector('#progress');
    const progressWrap = controls.querySelector('#player-progress');
    const prevBtn = controls.querySelector('#prev');
    const nextBtn = controls.querySelector('#next');
    const playBtn = controls.querySelector('#play');

     


    const audio = new Audio();
    let index = startIndex;
    let playing = false;

    const fmt = s => {
      if (!isFinite(s) || s < 0) s = 0;
      const m = Math.floor(s/60), sec = Math.floor(s%60);
      return `${m}:${String(sec).padStart(2,'0')}`;
    };

    // place near top of attachControls scope:
    let noteTimer = null;
    function typewriter(el, text, cps = 35) {
      // cps = characters per second
      clearInterval(noteTimer);
      el.textContent = '';
      let i = 0;
      const stepMs = Math.max(15, Math.round(1000 / cps));
      noteTimer = setInterval(() => {
        el.textContent = text.slice(0, ++i);
        if (i >= text.length) clearInterval(noteTimer);
      }, stepMs);
    }


    let bubbleBtn = null;    // ← add this near other locals

    function ensureNoteBubble(track) {
      if (!noteEl) return;

      const note = (track.note || '').trim();

      // If no note: remove bubble + hide note panel
      if (!note) {
        if (bubbleBtn) {
          bubbleBtn.remove();
          bubbleBtn = null;
        }
        noteEl.classList.remove('show');
        noteEl.style.display = 'none';
        noteEl.textContent = '';
        clearInterval(noteTimer);
        return;
      }

      // Ensure bubble exists once
      if (!bubbleBtn) {
        bubbleBtn = document.createElement('button');
        bubbleBtn.type = 'button';
        bubbleBtn.className = 'note-bubble';
        bubbleBtn.setAttribute('aria-label', 'Show track note');
        bubbleBtn.setAttribute('aria-pressed', 'false');

        // Inline speech-bubble SVG (accessible)
        bubbleBtn.innerHTML = `
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M20 14c0 1.1-.9 2-2 2H9l-4 3v-3H6c-1.1 0-2-.9-2-2V6
                     c0-1.1.9-2 2-2h12c1.1 0 2 .9 2 2v8z"></path>
          </svg>
        `;

        layer.appendChild(bubbleBtn);

        // Toggle behavior
        bubbleBtn.addEventListener('click', () => {
          const isOpen = noteEl.classList.toggle('show');

          if (isOpen) {
            // Build fresh span so typewriter restarts
            noteEl.style.display = 'block';
            noteEl.innerHTML = '<span class="tw-note"></span>';
            const tw = noteEl.querySelector('.tw-note');
            typewriter(tw, (TRACKS[index].note || '').trim(), 15);
            bubbleBtn.setAttribute('aria-pressed', 'true');
          } else {
            noteEl.classList.remove('show');
            noteEl.style.display = 'none';
            noteEl.textContent = '';
            clearInterval(noteTimer);
            bubbleBtn.setAttribute('aria-pressed', 'false');
          }
        });
      } else {
        // If bubble already exists, make sure it will show the current note when clicked
        bubbleBtn.setAttribute('aria-pressed', noteEl.classList.contains('show') ? 'true' : 'false');
      }
      
    }


    function load(i){
      const t = TRACKS[i];
      audio.src = t.audio;
      titleEl.textContent  = t.title  ?? `Track ${i+1}`;
      artistEl.textContent = t.artist ?? '';

        // Only show a bubble if a note exists; do NOT auto-open the note.
        ensureNoteBubble(t);
        // Hide note panel by default when a new track loads
        if (noteEl) {
          noteEl.classList.remove('show');
          noteEl.style.display = 'none';
          noteEl.textContent = '';
          clearInterval(noteTimer);
        }
  

      durEl.textContent = (typeof t.duration === 'number') ? fmt(t.duration) : '0:00';
      if (typeof t.duration !== 'number') {
        audio.addEventListener('loadedmetadata', () => durEl.textContent = fmt(audio.duration), { once:true });
      }
      progress.style.width = '0%';
      currentEl.textContent = '0:00';
    }



    function play(){ playing = true;  playBtn.classList.replace('fa-play','fa-pause'); playBtn.title='Pause'; audio.play(); }
    function pause(){ playing = false; playBtn.classList.replace('fa-pause','fa-play'); playBtn.title='Play'; audio.pause(); }
    function toggle(){ playing ? pause() : play(); }
    function change(dir){ index = (index + dir + TRACKS.length) % TRACKS.length; load(index); play(); activeIndex = index; }

    function update(){
      const { duration, currentTime } = audio;
      progress.style.width = duration ? (currentTime/duration*100)+'%' : '0%';
      currentEl.textContent = fmt(currentTime);
    }
    function seek(e){
      if (!audio.duration) return;
      const r = progressWrap.getBoundingClientRect();
      const pct = (e.clientX - r.left) / r.width;
      audio.currentTime = Math.max(0, Math.min(1, pct)) * audio.duration;
    }

    playBtn.addEventListener('click', toggle);
    // Seek helper: clamp to [0, duration]
    function seekBy(deltaSeconds){
      if (!isFinite(audio.duration)) return;                 // not ready yet
      const t = Math.max(0, Math.min(audio.duration, audio.currentTime + deltaSeconds));
      audio.currentTime = t;
      update();                                              // refresh progress/time labels
    }

    // NEW behavior
    prevBtn.title = 'Rewind 10s';
    nextBtn.title = 'Forward 10s';

    prevBtn.addEventListener('click', () => seekBy(-10));
    nextBtn.addEventListener('click', () => seekBy(+10));

    progressWrap.addEventListener('click', seek);
    audio.addEventListener('timeupdate', update);

// optional replacement to stop at end:
    audio.addEventListener('ended', () => { pause(); audio.currentTime = audio.duration || 0; update(); });


    load(startIndex);
    requestAnimationFrame(() =>{
      controls.classList.add('show');
      if (noteEl && noteEl.textContent.trim()) noteEl.classList.add('show'); // ← add
    });

    return { controls, teardown: () => { audio.pause(); audio.src=''; } };
  }

  function findImgRectByIndex(i){
    const el = [...document.querySelectorAll('.stack-card img')]
      .find(img => +img.dataset.trackIndex === i);
    return el ? { el, rect: el.getBoundingClientRect() } : null;
  }

  function cleanupPopout(){
    if (activeLayer?.parentNode) activeLayer.parentNode.removeChild(activeLayer);
    activeLayer = null;
    activeControls = null;
    activeIndex = null;
    if (typeof teardownControls === 'function') {
      teardownControls();
      teardownControls = null;
    }
  }

  function openPopoutFrom(imgEl, trackIndex){
    if (isAnimating) return;
    if (activeLayer) closePopout(true);

    const r = imgEl.getBoundingClientRect();
    const layer = document.createElement('div');
    layer.className = 'popout-layer';
    Object.assign(layer.style, {
      left: r.left+'px', top: r.top+'px', width: r.width+'px', height: r.height+'px'
    });

    const mask = document.createElement('div');
    mask.className = 'popout-card-mask';
    const cloned = imgEl.cloneNode(true);

    layer.appendChild(imgEl.cloneNode(true));
    document.body.appendChild(layer);

    const { controls, teardown } = attachControls(layer, trackIndex);
    activeLayer = layer; activeControls = controls; teardownControls = teardown; activeIndex = trackIndex;

    backdrop.classList.add('show');
    btnClose.classList.add('show');

    const vw = innerWidth, vh = innerHeight;
    const side = Math.min(vw, vh) * 0.86;
    const finalLeft = (vw - side) / 2;
    const finalTop  = (vh - side) / 2;

    isAnimating = true;
    layer.animate([
      { left:r.left+'px', top:r.top+'px', width:r.width+'px', height:r.height+'px',
        borderRadius:getComputedStyle(imgEl.parentElement).borderRadius },
      { left:finalLeft+'px', top:finalTop+'px', width:side+'px', height:side+'px', borderRadius:'20px' }
    ], { duration:460, easing:'cubic-bezier(0.22,1,0.36,1)', fill:'forwards' })
    .finished.finally(() => { isAnimating = false; });
  }

  function closePopout(immediate = false){
    if (!activeLayer || isAnimating) return;

    backdrop.classList.remove('show');
    btnClose.classList.remove('show');
    activeControls?.classList.remove('show');
    activeLayer?.querySelector('.popout-note')?.classList.remove('show'); // ← add

    activeLayer?.querySelector('.note-bubble')?.classList.add('hiding');

    if (immediate) { cleanupPopout(); return; }


    isAnimating = true;
    const layer = activeLayer;
    const start = layer.getBoundingClientRect();
    const found = findImgRectByIndex(activeIndex);

    const finish = () => { cleanupPopout(); isAnimating = false; };

    if (found) {
      const end = found.rect;
      const flyBack = layer.animate([
        { left: start.left+'px', top: start.top+'px', width: start.width+'px', height: start.height+'px', transform: 'scale(1)' },
        { left: end.left+'px',   top: end.top+'px',   width: end.width+'px',   height: end.height+'px',   transform: 'scale(0.985)' }
      ], { duration: 680, easing: 'cubic-bezier(0.16,1,0.3,1)', fill: 'forwards' });

      const fade = layer.animate([{ opacity: 1 }, { opacity: 0 }], { delay: 120, duration: 820, easing: 'ease-out', fill: 'forwards' });

      Promise.allSettled([flyBack.finished, fade.finished]).then(finish);
    } else {
      layer.animate(
        [{ opacity: 1, transform: 'scale(1)' }, { opacity: 0, transform: 'scale(0.98)' }],
        { duration: 700, easing: 'ease-out', fill: 'forwards' }
      ).finished.finally(finish);
    }
  }

  // Open
  document.addEventListener('click', (e) => {
    if (activeLayer) return;
    const card = e.target.closest('.stack-card');
    if (!card) return;
    e.preventDefault();
    const img = card.querySelector('img');
    const idx = +img.dataset.trackIndex;
    openPopoutFrom(img, idx);
  }, true);

  // Close
  backdrop?.addEventListener('click', () => closePopout());
  btnClose?.addEventListener('click', () => closePopout());

  // Keep centered if window resizes while open
  window.addEventListener('resize', () => {
    if(!activeLayer) return;
    const box = activeLayer.getBoundingClientRect();
    const vw = Math.max(document.documentElement.clientWidth  || 0, window.innerWidth  || 0);
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
    const side = Math.min(vw, vh) * 0.86;
    const finalLeft = (vw - side) / 2;
    const finalTop  = (vh - side) / 2;
    activeLayer.animate([
      { left: box.left+'px', top: box.top+'px', width: box.width+'px', height: box.height+'px' },
      { left: finalLeft+'px', top: finalTop+'px', width: side+'px', height: side+'px' }
    ], { duration: 240, easing: 'ease-out', fill: 'forwards' });
  });
})();
</script>














<!-- The playback system -->
<!-- <script>
  const image = document.getElementById('cover'),
    title = document.getElementById('music-title'),
    artist = document.getElementById('music-artist'),
    currentTimeEl = document.getElementById('current-time'),
    durationEl = document.getElementById('duration'),
    progress = document.getElementById('progress'),
    playerProgress = document.getElementById('player-progress'),
    prevBtn = document.getElementById('prev'),
    nextBtn = document.getElementById('next'),
    playBtn = document.getElementById('play'),
    background = document.getElementById('bg-img');


let musicIndex = 0;
let isPlaying = false;

function togglePlay() {
    if (isPlaying) {
        pauseMusic();
    } else {
        playMusic();
    }
}

function playMusic() {
    isPlaying = true;
    // Change play button icon
    playBtn.classList.replace('fa-play', 'fa-pause');
    // Set button hover title
    playBtn.setAttribute('title', 'Pause');
    music.play();
}

function pauseMusic() {
    isPlaying = false;
    // Change pause button icon
    playBtn.classList.replace('fa-pause', 'fa-play');
    // Set button hover title
    playBtn.setAttribute('title', 'Play');
    music.pause();
}

function loadMusic(song) {
    music.src = song.path;
    title.textContent = song.displayName;
    artist.textContent = song.artist;
    image.src = song.cover;
    background.src = song.cover;
}

function changeMusic(direction) {
    musicIndex = (musicIndex + direction + songs.length) % songs.length;
    loadMusic(songs[musicIndex]);
    playMusic();
}

function updateProgressBar() {
    const { duration, currentTime } = music;
    const progressPercent = (currentTime / duration) * 100;
    progress.style.width = `${progressPercent}%`;

    const formatTime = (time) => String(Math.floor(time)).padStart(2, '0');
    durationEl.textContent = `${formatTime(duration / 60)}:${formatTime(duration % 60)}`;
    currentTimeEl.textContent = `${formatTime(currentTime / 60)}:${formatTime(currentTime % 60)}`;
}

function setProgressBar(e) {
    const width = playerProgress.clientWidth;
    const clickX = e.offsetX;
    music.currentTime = (clickX / width) * music.duration;
}

playBtn.addEventListener('click', togglePlay);
prevBtn.addEventListener('click', () => changeMusic(-1));
nextBtn.addEventListener('click', () => changeMusic(1));
music.addEventListener('ended', () => changeMusic(1));
music.addEventListener('timeupdate', updateProgressBar);
playerProgress.addEventListener('click', setProgressBar);

loadMusic(songs[musicIndex]);
</script> -->

  
</body>
</html>
